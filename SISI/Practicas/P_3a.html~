<!DOCTYPE html>
<html lang="es">
<head>
<!-- 2022-05-13 Fri 14:30 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Practica 3A</title>
<meta name="author" content="Alberto Robles Gomez" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../../css/index.css" />
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Practica 3A</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd357391">Diseño de un sistema de informacion</a></li>
</ul>
</div>
</nav>
<div id="outline-container-orgd357391" class="outline-2">
<h2 id="orgd357391">Diseño de un sistema de informacion</h2>
<div class="outline-text-2" id="text-orgd357391">
<ol class="org-ol">
<li><p>
Realizad un particionado del espacio de disco duro, teniendo en
cuenta que por eficiencia necesitaremos al menos tres particiones:
</p>

<ol class="org-ol">
<li>Sistema Operativo (una o varias en funcion del numero de SO)</li>
<li>Datos</li>
<li>Backups</li>
</ol>

<p>
Pasos que he realizado:
</p>

<ul class="org-ul">
<li><p>
Primero de todo: creacion de la VM
</p>


<figure id="org4e89ab7">
<img src="./img/3.1.1.png" alt="3.1.1.png">

</figure>


<figure id="org3fcc459">
<img src="./img/3.1.2.png" alt="3.1.2.png">

</figure>

<p>
Habilitare efi, para que sea como una instalacion en una maquina
mas actual:
</p>


<figure id="orgb2b5919">
<img src="./img/3.1.3.png" alt="3.1.3.png">

</figure>

<p>
Añado la ISO del OS, que sera nixOS:
</p>


<figure id="orgc21a1bb">
<img src="./img/3.1.4.png" alt="3.1.4.png">

</figure>

<p>
Arranco la VM y selecciono la primera opcion:
</p>


<figure id="org0b4ecac">
<img src="./img/3.1.5.png" alt="3.1.5.png">

</figure></li>

<li><p>
Una vez arrancado, lo siguiente es particionar el disco.
</p>

<p>
Hechamos un vistazo a los discos:
</p>


<figure id="org233b8bf">
<img src="./img/3.1.6.png" alt="3.1.6.png">

</figure>

<p>
Lo primaro es a cambiar a root e ir a <code>/</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">sudo su

<span class="org-builtin">cd</span> /
</pre>
</div>

<p>
Con <code>fdisk</code> sobre el disco duro creamos las particiones:
</p>

<div class="org-src-container">
<pre class="src src-shell">sudo fdisk /dev/sda
</pre>
</div>

<p>
Le asigno el particionado GPT y creamos 2 particiones, una de
512MiB-1GiB para la efi y otra con el resto del espacio que sobra.
</p>


<figure id="org7fe00e9">
<img src="./img/3.1.8.png" alt="3.1.8.png">

</figure>

<p>
A la particion efi la pongo de tipo <code>EFI System</code>.
</p>


<figure id="org2f207fa">
<img src="./img/3.1.9.png" alt="3.1.9.png">

</figure>

<p>
Y por ultimo se guardan los cambios.
</p>


<figure id="org1eeec2f">
<img src="./img/3.1.10.png" alt="3.1.10.png">

</figure>

<p>
Formateo las particiones, la efi con <code>fat32</code> y la otra con <code>btrfs</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">mkfs.fat -F 32 -n BOOT /dev/sda1

mkfs.btrfs -L SYSTEM /dev/sda2
</pre>
</div>

<p>
Monto la particion del sistema y creo los diferentes subvolumenes;
datos, backups y el del SO:
</p>

<div class="org-src-container">
<pre class="src src-shell">mount /dev/sda2 /mnt

btrfs subvolume create /mnt/@data

btrfs subvolume create /mnt/@backups

btrfs subvolume create /mnt/@nixos
</pre>
</div>

<p>
Desmonto <code>/mnt</code> y monto el subvolumen <code>@nixos</code>, seguido de crear
su <code>/boot</code> y montarle la particion de boot y lo mismo creando
<code>/Datos</code> y <code>/Backups</code>, montandoles sus respectivos subvolumenes:
</p>

<div class="org-src-container">
<pre class="src src-shell">umount /mnt

mount /dev/sda2 -o <span class="org-variable-name">subvol</span>=@nixos /mnt

mkdir /mnt/boot

mount /dev/sda1 /mnt/boot

mkdir /mnt/Datos /mnt/Backups

mount /dev/sda2 -o <span class="org-variable-name">subvol</span>=@data /mnt/Datos

mount /dev/sda2 -o <span class="org-variable-name">subvol</span>=@backups /mnt/Backups
</pre>
</div>

<p>
Y me acabo de acordar, deberia crear una swap, asi que monto en un
directorio aparte <code>/dev/sda2</code> de nuevo y le creo el subvolumen
para la swap:
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir /mnt2

mount /dev/sda2 /mnt2

btrfs subvolume create /mnt2/@swap

umount /mnt2
</pre>
</div>

<p>
Creo <code>/swap</code>, donde se montara el subvolumen creado antes:
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir /mnt/swap

mount /dev/sda2 -o <span class="org-variable-name">subvol</span>=@swap /mnt/swap
</pre>
</div>

<p>
Pero eso de poco sirve, normalmente se suele crear una particion
aparte, a la que se le realiza un <code>swapon</code> para usarla como swap,
en caso de no usar una particion, se puede crear un <code>swapfile</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">touch /mnt/swap/swapfile
</pre>
</div>

<p>
Ahora bien, no queremos que nadie que no sea el sistema pueda
toquetear la swap, y aparte tenemos que deshabilitar el COW (Copy
on Write) para que btrfs no haga de las suyas:
</p>

<div class="org-src-container">
<pre class="src src-shell">chmod 600 /mnt/swap/swapfile

chattr +C /mnt/swap/swapfile
</pre>
</div>

<p>
Por ultimo, hay que darle un tamaño a la swapfile, formatearlo y
hacerle <code>swapon</code> (el tamaño es el valor de count multiplicado por
lo que se de en el blocksize, BS):
</p>

<div class="org-src-container">
<pre class="src src-shell">dd <span class="org-variable-name">if</span>=/dev/zero <span class="org-variable-name">of</span>=/mnt/swap/swapfile <span class="org-variable-name">bs</span>=1M <span class="org-variable-name">count</span>=2048
<span class="org-comment-delimiter"># </span><span class="org-comment">2048+0 records in</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2048+0 records out</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2147483648 bytes (2 GiB) copied, 20 s, 105 MB/s</span>

mkswap /mnt/swap/swapfile
<span class="org-comment-delimiter"># </span><span class="org-comment">Setting up swapspace version 1, size = 2 GiB</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">no label, UUID=8d33617c-9642-4c9a4-ae68-9885a67bbea5</span>

swapon /mnt/swap/swapfile
</pre>
</div></li>

<li><p>
Ahora toca instalar el OS. En nixOS es de una forma no muy
habitual.
</p>

<p>
Primero de todo, generar una configuracion para instalar nixos,
que se guarda en <code>/etc/nixos</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">nixos-generate-config --root /mnt
<span class="org-comment-delimiter"># </span><span class="org-comment">writing /mnt/etc/nixos/hardware-configuration.nix...</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">writing /mnt/etc/nixos/configuration.nix...</span>

<span class="org-builtin">cd</span> /mnt/etc/nixos/
</pre>
</div>

<p>
Existen 2 archivos, <code>configuration.nix</code> y
<code>hardware-configuration.nix</code>, uno tiene configuracion del sistema
y el otro del hardware, por ejemplo de como montar los discos.
</p>

<p>
Primero voy a ver si el de hardware esta bien:
</p>

<div class="org-src-container">
<pre class="src src-nix">{ config, lib, pkgs, modulesPath, ... }:

{
  imports = [ ];

  boot.initrd.availableKernelModules = [
    "ata_piix"
    "ohci_pci"
    "sd_mod"
    "sr_mod"
  ];

  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ ];
  boot.extraModulePackages = [ ];

  fileSystems."/" = {
    device = "/dev/disk/by-uuid/5a3613a9-814e-4a71-ba4c-53aea68a03bd";
    fsType = "btrfs";
    options = [ "subvol=@nixos" ];
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/A795-88BB";
    fsType = "vfat";
  };

  fileSystems."/Datos" = {
    device = "/dev/disk/by-uuid/5a3613a9-814e-4a71-ba4c-53aea68a03bd";
    fsType = "btrfs";
    options = [ "subvol=@data" ];
  };

  fileSystems."/Backups" = {
    device = "/dev/disk/by-uuid/5a3613a9-814e-4a71-ba4c-53aea68a03bd";
    fsType = "btrfs";
    options = [ "subvol=@backups" ];
  };

  fileSystems."/swap" = {
    device = "/dev/disk/by-uuid/5a3613a9-814e-4a71-ba4c-53aea68a03bd";
    fsType = "btrfs";
    options = [ "subvol=@swap" ];
  };

  swapDevices = [ ];

  virtualisation.virtualbox.guest.enable = true;
}
</pre>
</div>

<p>
Parece que no detecto que tenemos un swapfile, asi que se lo
añado:
</p>

<div class="org-src-container">
<pre class="src src-nix">swapDevices = [ { device = "/swap/swapfile"; } ];
</pre>
</div>

<p>
Ahora he editado <code>configuration.nix</code>, quitado los comentarios y
configuraciones innecesarias, crado un usuario pruebas con una
contraseña super segura, añadido un editor de texto y el resto es
por defecto.
</p>

<div class="org-src-container">
<pre class="src src-nix">{ config, pkgs, ... }:

{
  imports =
    [
      ./hardware-configuration.nix
    ];

  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  networking.hostName = "SISI_nixos";

  time.timeZone = "Europe/Madrid";

  networking.useDHCP = false;
  networking.interfaces.enp0s3.useDHCP = true;

  i18n.defaultLocale = "en_US.UTF-8";

  users.mutableUsers = false;
  users.users.pruebas = {
    isNormalUser = true;
    createHome = true;
    password = "1234";
    extraGroups = [ "wheel" ];
  };

  environment.systemPackages = with pkgs; [
    neovim
  ];

  system.stateVersion = "21.05";
}
</pre>
</div>

<p>
Y con esto y un bizcocho, rezamos para que instale:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">cd</span> /

nixos-install
</pre>
</div>

<p>
Empieza a instalar todo y generar las configuraciones, y por
ultimo nos pregunta para poner la contraseña de root:
</p>


<figure id="org48c729b">
<img src="./img/3.1.25.png" alt="3.1.25.png">

</figure>

<p>
Y ya solo queda hacer <code>reboot</code>. El sistema funciona al arrancar
perfectamente.
</p>


<figure id="orgd9f1273">
<img src="./img/3.1.26.png" alt="3.1.26.png">

</figure>

<p>
Inicio sesion con el usuario que cree y compruebo que todo esta
montado.
</p>


<figure id="org08c8033">
<img src="./img/3.1.27.png" alt="3.1.27.png">

</figure></li>
</ul></li>

<li><p>
Configura la creacion de copias de seguridad de los datos, que se
guardaran en la particion correspondiente (combino este ejercicio
con el 3, para hacerlo 'todo de una'):
</p>

<ol class="org-ol">
<li>Copia completa cada tres meses, sabado a las 9am</li>
<li>Copia diferencial cada dos semanas, sabado a las 9am</li>
<li>Copia incremental todos los dias a las 10 de la noche</li>
</ol>

<p>
Esto usando nixOS y btrfs es muy sencillo:
</p>

<ul class="org-ul">
<li><p>
Primero vamos con las copias completas:
</p>

<p>
Como antes, nos vamos a la configuracion de nixOS:
</p>

<div class="org-src-container">
<pre class="src src-shell">sudo su

<span class="org-builtin">cd</span> /etc/nixos/
</pre>
</div>

<p>
Vamos a usar systemd para crear unos servicios que se ejecuten en
determinadas fechas (systemd-timers calendar events). La sintaxis
es sencilla, le doy un nombre al servicio, en este caso
<code>'fullBackup'</code> junto a una descripcion. Ahora le configuro para
que solo se ejecute los sabados de la primera semana de Enero,
Abril, Julio y Octubre, es decir cada 4 meses, a las 9 de la
mañana.
</p>

<div class="org-src-container">
<pre class="src src-nix">{ config, pkgs, ... }:

{
  # ...

  system.stateVersion = "21.05";

  systemd.services = {
    fullBackup = {
      description = "Realizar una copia comleta";
      startAt = "Sat *-01,04,07,10-1..7 09:00:00";
    };
  };
}
</pre>
</div>

<p>
Ahora hay que decirle que orden tiene que ejecutar, que sera que
haga una snapshot readonly (<code>-r</code>) del subvolumen <code>/Datos</code> en el
subvolumen <code>/Backups</code> y de nombre le da <code>'full'</code>, que quedaria
tal que asi:
</p>

<div class="org-src-container">
<pre class="src src-nix">fullBackup = {
  description = "Realizar una copia comleta";
  startAt = "Sat *-01,04,07,10-1..7 09:00:00";
  script = "btrfs subvolume snapshot -r /Datos /Backups/full";
};
</pre>
</div>

<p>
Ahora bien, el problema es que el script no tiene importado el
<code>PATH</code> que un usuario normal tiene, por lo que no sabe que es el
comando <code>btrfs</code>, asi que tenemos que decirle donde se encuentra
el comando. El atributo <code>path</code> toma una lista de paquetes y de
cada uno toma lo que tienen en su <code>bin/</code>, en este caso el paquete
en el que se encuentra el comando btrfs se llama <code>btrfs-progs</code> y
todos los paquetes se encuentran dentro del modulo <code>pkgs</code>:
</p>

<div class="org-src-container">
<pre class="src src-nix">fullBackup = {
  description = "Realizar una copia comleta";
  startAt = "Sat *-01,04,07,10-1..7 09:00:00";
  script = "btrfs subvolume snapshot -r /Datos /Backups/full";
  path = [ pkgs.btrfs-progs ];
};
</pre>
</div>

<p>
Ahora bien, las snapshots se deberian nombrar de forma
incremental, tal que si existe una anterior completa, genere la
siguiente, si no existe ninguna, genera la 1, asi quedaria el
script:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">Path de la ultima backup completa</span>
<span class="org-variable-name">LFB</span>=$(find /Backups -type d -name <span class="org-string">"full_*"</span> | tail -n1)

<span class="org-comment-delimiter"># </span><span class="org-comment">Si no existe una anterior backup completa, esta sera la 1</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Si no esta sera la siguiente (si es 1, pues 2)</span>
<span class="org-keyword">if</span> [[ -z $<span class="org-variable-name">LFB</span> ]]; <span class="org-keyword">then</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Nombre de la nueva backup</span>
  <span class="org-variable-name">NBN</span>=full_1
<span class="org-keyword">else</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la ultima backup completa</span>
  <span class="org-variable-name">LFBN</span>=$(<span class="org-builtin">echo</span> <span class="org-string">"$LFB"</span> | sed <span class="org-string">"s/.*\/full_\(.*\)/\1/g"</span>)
  <span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la siguiente backup completa</span>
  <span class="org-variable-name">NFBN</span>=$(($<span class="org-variable-name">LFBN</span> + 1))
  <span class="org-comment-delimiter"># </span><span class="org-comment">Nombre de la nueva backup</span>
  <span class="org-variable-name">NBN</span>=full_$<span class="org-variable-name">NFBN</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Borrar todas las backups locales</span>
  btrfs subvolume delete /Backups/*
<span class="org-keyword">fi</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Creamos una snapshot de /Datos y la guardamos en local</span>
btrfs subvolume snapshot -r /Datos /Backups/$<span class="org-variable-name">NBN</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Enviamos la snapshot al remoto</span>
btrfs send /Backups/$<span class="org-variable-name">NBN</span> | btrfs receive /Remoto
</pre>
</div>

<p>
Notese tambien como he creado un <code>/Remoto</code>, esto se debe a que
normalmente no queremos guardar las copias de seguridad en local,
si no en un servidor remoto o un NAS. Si se quieren guardar en
local, el directorio <code>/Backups</code> seria tratado como un contenedor
temporal de backups, ya que al enviarlas ya no son necesarias y
se eliminan. (Sobre la opcion <code>send</code> y <code>receive</code> hablo mas
abajo).
</p></li>

<li><p>
Ahora hare para las copias diferenciales:
</p>

<p>
Para realizar esto en btrfs existe el comando <code>send</code> y <code>receive</code>,
<code>send</code> puede tomar una snapshot padre y otra snapshot que derive
de el (solo si le pasamos el <code>-p</code>, sino simplemente envia la
snapshot, como un <code>mv</code>), determinar las diferencias entre ellos y
lo envia por un stream de datos, que se puede guardar en un
archivo o usar <code>receive</code> para que guarde esos cambios en forma de
una nueva snapshot.
</p>

<div class="org-src-container">
<pre class="src src-nix">diferentialBackup = {
  description = "Realizar una copia diferencial";
  startAt = "Sat *-*-1..7,15-21 09:00:00";
  script =
    ''
    # Copy paste de lo de abajo
    '';
  path = [ pkgs.btrfs-progs ];
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">Path de la ultima backup completa</span>
<span class="org-variable-name">LFB</span>=$(find /Backups -type d -name <span class="org-string">"full_*"</span> | tail -n1)
<span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la ultima backup completa</span>
<span class="org-variable-name">LFBN</span>=$(<span class="org-builtin">echo</span> <span class="org-string">"$LFB"</span> | sed <span class="org-string">"s/.*\/full_\(.*\)/\1/g"</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">Path de la ultima backup diferencial</span>
<span class="org-variable-name">LDB</span>=$(find /Backups -type d -name <span class="org-string">"diferential_$LFBN-*"</span> | tail -n1)

<span class="org-comment-delimiter"># </span><span class="org-comment">Si no existe una anterior backup diferencial, esta sera la 1</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Si existe el nombre sera la siguiente</span>
<span class="org-keyword">if</span> [[ -z $<span class="org-variable-name">LDB</span> ]]; <span class="org-keyword">then</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Nombre de la nueva backup</span>
  <span class="org-variable-name">NBN</span>=diferential_$<span class="org-variable-name">LFBN</span>-1
<span class="org-keyword">else</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la anterior backup diferencial</span>
  <span class="org-variable-name">LDBN</span>=$(<span class="org-builtin">echo</span> <span class="org-string">"$LDB"</span> | sed <span class="org-string">"s/.*\/diferential_.*-\(.*\)/\1/g"</span>)
  <span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la siguiente backup diferencial</span>
  <span class="org-variable-name">NDBN</span>=$(($<span class="org-variable-name">LDBN</span> + 1))
  <span class="org-comment-delimiter"># </span><span class="org-comment">Nombre de la nueva backup</span>
  <span class="org-variable-name">NBN</span>=diferential_$<span class="org-variable-name">LFBN</span>-$<span class="org-variable-name">NDBN</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Se elimina la anterior copia diferencial en local</span>
  btrfs subvolume delete $<span class="org-variable-name">LDB</span>
<span class="org-keyword">fi</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Creamos una snapshot de /Datos y la guardamos en local</span>
btrfs subvolume snapshot -r /Datos /Backups/$<span class="org-variable-name">NBN</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Se forma un stream de diferencias entre la ultima backup completa</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">y el estado actual, que se guardo en local en el comando anterior</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Este stream se evia al remote y este lo interpreta creando la</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">copia diferencial</span>
btrfs send -p $<span class="org-variable-name">LFB</span> /Backups/$<span class="org-variable-name">NBN</span> | btrfs receive /Remoto
</pre>
</div></li>

<li><p>
Por ultimo las incrementales:
</p>

<p>
Lo mismo que con las diferenciales, solo hay que cambiar un par
de cosas:
</p>

<div class="org-src-container">
<pre class="src src-nix">incrementalBackup = {
  description = "Realizar una copia incremental";
  startAt = "*-*-* 22:00:00";
  script =
    ''
    # Copy paste de lo de abajo
    '';
  path = [ pkgs.btrfs-progs ];
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">Path de la ultima backup completa</span>
<span class="org-variable-name">LFB</span>=$(find /Backups -type d -name <span class="org-string">"full_*"</span> | tail -n1)
<span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la ultima backup completa</span>
<span class="org-variable-name">LFBN</span>=$(<span class="org-builtin">echo</span> <span class="org-string">"$LFB"</span> | sed <span class="org-string">"s/.*\/full_\(.*\)/\1/g"</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">Path de la ultima backup diferencial</span>
<span class="org-variable-name">LDB</span>=$(find /Backups -type d -name <span class="org-string">"diferential_$LFBN-*"</span> | tail -n1)
<span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la ultima backup diferencial</span>
<span class="org-variable-name">LDBN</span>=$(<span class="org-builtin">echo</span> <span class="org-string">"$LDB"</span> | sed <span class="org-string">"s/.*\/diferential_.*-\(.*\)/\1/g"</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">Path de la ultima backup incremental</span>
<span class="org-variable-name">LIB</span>=$(find /Backups -type d -name <span class="org-string">"incremental_$LFBN-$LDBN-*"</span> | tail -n1)

<span class="org-comment-delimiter"># </span><span class="org-comment">Si no existe una anterior backup incremental, esta sera la 1</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Si existe el nombre sera la siguiente</span>
<span class="org-keyword">if</span> [[ -z $<span class="org-variable-name">LIB</span> ]]; <span class="org-keyword">then</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Nombre de la nueva backup</span>
  <span class="org-variable-name">NBN</span>=incremental_$<span class="org-variable-name">LFBN</span>-$<span class="org-variable-name">LDBN</span>-1
  <span class="org-comment-delimiter"># </span><span class="org-comment">Path de la copia con la que se debe comparar</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">como no hay incrementales sera la ultima diferencial</span>
  <span class="org-variable-name">PARENT</span>=$<span class="org-variable-name">LDB</span>
<span class="org-keyword">else</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la anterior backup incremental</span>
  <span class="org-variable-name">LIBN</span>=$(<span class="org-builtin">echo</span> <span class="org-string">"$LIB"</span> | sed <span class="org-string">"s/.*\/incremental_.*-.*-\(.*\)/\1/g"</span>)
  <span class="org-comment-delimiter"># </span><span class="org-comment">Numero / ID de la siguiente backup incremental</span>
  <span class="org-variable-name">NIBN</span>=$(($<span class="org-variable-name">LIBN</span> + 1))
  <span class="org-comment-delimiter"># </span><span class="org-comment">Nombre de la nueva backup</span>
  <span class="org-variable-name">NBN</span>=incremental_$<span class="org-variable-name">LFBN</span>-$<span class="org-variable-name">LDBN</span>-$<span class="org-variable-name">NIBN</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Path de la copia con la que se debe comparar</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">como existe una anterior incremental, esa sera</span>
  <span class="org-variable-name">PARENT</span>=$<span class="org-variable-name">LIB</span>
<span class="org-keyword">fi</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Creamos una snapshot de /Datos y la guardamos en local</span>
btrfs subvolume snapshot -r /Datos /Backups/$<span class="org-variable-name">NBN</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Se forma un stream de diferencias entre la backup "PADRE"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">y el estado actual, que se guardo en local en el comando anterior</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Este stream se evia al remote y este lo interpreta creando la</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">copia incremental</span>
btrfs send -p $<span class="org-variable-name">PARENT</span> /Backups/$<span class="org-variable-name">NBN</span> | btrfs receive /Remoto
<span class="org-comment-delimiter"># </span><span class="org-comment">Me cargo la anterior incremental en local si es que habia</span>
[[ -z $<span class="org-variable-name">NIBN</span> ]] || btrfs subvolume delete $<span class="org-variable-name">PARENT</span>
</pre>
</div></li>

<li><p>
Demostracion de que funciona
</p>

<p>
Para demostrar que todo esto funciona solo queda aplicar la
configuracion y probar.
</p>

<div class="org-src-container">
<pre class="src src-shell">nixos-rebuild switch
</pre>
</div>

<p>
Y a hacer las pruebas (entre cada creacion de una copia,
creaba/editaba un archivo en <code>/Datos</code>):
</p>

<p>
Primero creare un falso remoto para la simulacion
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir /Remoto
</pre>
</div>

<p>
Ahora voy a forzar al servicio para que se ejecute:
</p>


<figure id="orgcdd9e9a">
<img src="./img/3.2.1.png" alt="3.2.1.png">

</figure>


<figure id="orgfbd02b8">
<img src="./img/3.2.2.png" alt="3.2.2.png">

</figure>


<figure id="org342465f">
<img src="./img/3.2.3.png" alt="3.2.3.png">

</figure>


<figure id="orge5a8bc7">
<img src="./img/3.2.4.png" alt="3.2.4.png">

</figure>

<p>
Y por ultimo al comprobar la informacion de cada snapshot en el
remoto, se puede ver como cada uno marca que tiene un snapshot
que desciende de el, menos el incremental 1-1-2 que es el ultimo.
</p>


<figure id="org2de3ddf">
<img src="./img/3.2.5.png" alt="3.2.5.png">

</figure></li>
</ul></li>

<li value="4"><p>
Realiza una valoracion de las necesidades para un
desarrollador de software.
</p>

<p>
Un desarrollador de software necesita, como minimo, de un editor de
texto, ya puede ser desde un bloc de notas como el notepad de
windows o el <code>ed</code> de linux, aunque no es bien recomendado si se
busca realizar un proyecto que contenga de varios ficheros, ya que
se puede volver bastante tedioso. Hoy en dia se suelen utilizar
editores que ofrecen ventajas como coloreado de sintaxis, marcado
de errores que se pueden dar en el proceso de compilacion sin
realizar este, prediccion de lo que vas a escribir o plantillas de
codigo entre muchas otras ayudas.
</p>

<p>
Dependiendo del lenguaje que se quiera utilizar, se necesitaran
de una serie de compiladores o interpretes, si se quieren usar
frameworks o librerias, etc.
</p>

<p>
Aparte de todo esto, si se busca realizar proyectos web, se
necesitara de un servidor en el que mantener el servicio; si se
quiere mantener una buena organizacion del codigo desarrollado en
equipo y realizar testing junto a otras cosas, se puede usar git y
pipelines devOps (CI y CD) para la automatizacion de las tareas de
testing y deploy.
</p>

<p>
Este es un resumen bastante breve, ya que creo que en el siguiente
punto se extiende lo que este trata de preguntar.
</p></li>

<li><p>
Valora cuales de las siguientes utilidades informaticas seria
preciso tener (ademas de la suite ofimatica) para un desarrollador
de software, e instala las que consideres.
</p>

<p>
Antes de empezar, me gustaria decir que no hay ninguna necesidad de
tener una suite ofimatica. Si se quiere realizar documentos del
tipo docx o doc, existen formatos de marcado como el md, tex y org
que ofrecen algo mucho mas simple y dan un mejor resultado, 100%
portable e incluso facilmente renderizable en el navegador.
</p>

<ol class="org-ol">
<li><p>
Utilidades de difusion:
</p>

<p>
Aqui sin ninguna duda entra en juego stackoverflow, uno de los
sitios mas repletos (por no decir el que mas) de informacion y
preguntas realizadas sobre cualquier ambito de programacion,
sistemas, redes, etc. Comunmente conocido como el paraiso del
programador, el 99% de tus dudas estan ahi resueltas.
</p>

<p>
Por otro lado tambien existen varios subreddits que pueden
ayudar, como por ejemplo r/linux.
</p>

<p>
Y otro de los grandes son las webs que contienen documentacion
de diferentes lenguajes, estandares, etc. Como mozilla.org,
w3schools.com, archlinux.org, etc.
</p></li>

<li><p>
Utilidades de almacenamiento compartido:
</p>

<p>
Esto es algo que con la existencia de github y parecidos
servicios ha dejado de usarse bastante, algunos de los mas
usados por la comunidad para pasar conocimiento (libros y demas
cosas no muy legales) serian mega y mediafire.
</p></li>

<li><p>
Utilidades de desarrollo:
</p>

<p>
Sobre el tema de editores de texto / IDE, cada persona tiene su
propio entorno de trabajo al que esta acostumbrado, en mi caso
uso emacs con evil mode (emacs + vim) y habra gente que use
vscode, atom o cualquier otra.
</p></li>

<li><p>
Repositorios:
</p>

<p>
Aqui el ganador es git, es poca la gente que sigue sin cambiar a
git (normalmente antiguos proyectos que empezaron usando otra
herramienta) y practicamente se ha convertido en standard, sobre
todo para la comunidad del open source.
</p></li>

<li><p>
Utilidades de trabajo colaborativo:
</p>

<p>
Normalmente, si usas git y de remoto github, se suele usar
varias de las utilidades que ofrece como son las listas de TODOs
(github projects) que permiten crear listas de cosas que hay que
hacer, fechas para las que deberian estar, marcas las
completadas, etc. Tambien las issues, que consisten de reportes
de errores en los que se discuten como arreglar el bug, nuevas
features, etc, y eso combinado con las pull requests que
permiten que ajenos al proyecto envien codigo a revisar por los
propietarios y que acaba siendo integrado, suelen normalmente
resolver bugs.
</p>

<p>
Otros tambien bastante utilizados son slack y discord.
</p></li>

<li><p>
Utilidades de anotacion y referencias:
</p>

<p>
Como explique el anterior punto sobre los github projects, eso
es lo mas usado, aparte de utilizar comentarios en el codigo y
ficheros md y org indicando referencias.
</p></li>
</ol></li>

<li><p>
Para las decisiones anteriores, ten en cuenta las licencias de
software.
</p>

<p>
Todo lo mencionado (excluyendo slack y discord) son software libre,
en mi caso mi setup de mi entorno de trabajo es 100% software
libre, quitando alguna herramienta que solo utilizo debido a
cualquier asignatura que requiera de ella, pero que cuando son
innecesarias vuelven a la tumba.
</p>

<p>
Una lista de todo lo que utilizo se puede ver en el repositorio que
tengo en github de mis archivos de configuracion <a href="https://github.com/aru-hackZ/Dotfiles.nix">aqui</a>.
</p></li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: Alberto Robles Gomez</p>
<p class="date">Created: 2022-05-13 Fri 14:30</p>
</div>
</body>
</html>
